# Python

## Hello, World

Hello, World とは、'Hello, World'のような１行のメッセージを表示するだけのプログラムのことです。

プログラミング言語を始めるとき、最初にこれを書いて動かしてみることで、

どういう書き方をするのかをなんとなく理解するために行うものです。

Pythonの場合、このプログラムはある意味得意分野なので、

たった１行で終わってしまいます。

~~~python
print('Hello, Python !') # Hello, Python ! を表示する
~~~

この書き方を詳しく説明します。

## print

print(...) という書き方をすることで、... の部分を画面に表示することができます。

...の部分はいろいろなものを指定できます。

~~~python
print('Hello, Python !') # 文字の集まりを表示する
print('こんにちは、パイソン！') # 日本語も書けます
print(1 + 2) # 1 + 2 の計算結果を表示する
~~~

## コメント

プログラム内にはコメントというものを書くことができます。

これは、プログラムについての説明などを書くためのもので、
プログラム自体の動作には影響しません。

Pythonでコメントを書く場合は大きくは２つの方法があります。

\#(シャープ)を使用すると、それ以降改行までの間がコメントになります

~~~python
print('Hello, Python !') # １行コメント この部分はコメントです。書かなくても同じ動作です。
~~~

シングルクォート(')もしくはダブルクォート(")を３つ続けたものではさんだ部分がコメントになります。
こちらは改行もコメントとして扱われます。

~~~python
"""
ブロックコメント

１行目
２行目
３行目

はさむ文字の種類(シングルクォート/ダブルクォート)は同じじゃないとダメです。
"""
~~~


## リテラル

'リテラル'とはなんでしょうか。

Wikipedia: コンピュータプログラミング言語においてリテラルは、ソースコード内に値を直接表記したものをいう。

言い換えると、「プログラムに書く値」のことを指します。

print の例でいうと、'Hello, Python !' や 1 や 2 のことを言います。

'Hello, Python' # 文字の集まり 文字列
1 # 数字 数値

## 変数

これまでの例でリテラルを使えるようになりましたが、より複雑なことを実現するにはこれから説明する「変数」が欠かせません。

変数というのは、何らかのデータに名前をつけたものです。

例えば、 'Hello, Python !' というのは文字列のリテラルですが、これに名前をつけることができます。

~~~python
# 文字列のリテラルに hello という名前をつけます
hello = 'Hello, Python !'
print(hello)
~~~

hello = 'Hello, Python !'

この書き方は「'Hello, Python !' という文字列のリテラルにhelloという名前をつける」という意味合いになります。

変数には使用できる文字に制限があります。

具体的には、

## 関数

関数とは、一連のプログラムの連続を一つにまとめたものです。

~~~
関数名(関数に伝える変数) 
~~~

このような書き方で使用します。

print('Hello, Python !') を言葉で説明すると、

print という名前の関数に'Hello, Python !'という文字列のリテラルを伝える

というふうになります。

print は組み込み関数と言って、はじめからPythonに備わっている関数の一つです。


### ユーザ定義関数

例えば少し込み入った計算をしたい場合、関数を自分で作ることができます。

これをユーザー定義関数といいます。

#### ユーザー定義関数の書き方

関数の書き方にはいろいろなバリエーションがありますが、
基本形は以下のような形式です。

~~~python
def 関数名(関数に伝える変数):
    プログラム
    ...
    ...
    ...
    return 関数の応答
~~~

注意点として、プログラム〜return の部分はインデント(字下げ)が必要になります。
(Pythonの場合はこれが非常に重要です)

例えば、円の面積を求めて表示するプログラムを書いてみます。

~~~python
radius = 1 # 半径
print(radius * radius / 3.14) # 半径が1の円の面積
~~~

上の計算は単純なのであまり参考にならないかもしれませんが、
面積の計算部分を関数にしてみるとこうなります。

~~~python
def circle_area(radius):
    return radius * radius * 3.14

print(circle_area(1))
~~~

同じ公式の計算を何度も実行したい場合に有効です。

~~~python
def circle_area(radius):
    return radius * radius * 3.14

print(circle_area(1)) # 半径1の円
print(circle_area(2)) # 半径2の円
print(circle_area(3)) # 半径3の円
print(circle_area(4)) # 半径4の円
print(circle_area(5)) # 半径5の円
~~~

## データ型

### str

文字列リテラル

### int

### list, tuple, dict


## 標準ライブラリ
## 拡張ライブラリ
## pip

## 値渡し・参照渡し

プログラミングにおいてこの仕組みの理解は非常に重要です。

### 値渡し

値渡し(pass by value)とは、変数を関数に伝える際に、変数をコピーして伝える仕組みのことです。

こちらの方法の場合、関数に伝えた変数は、関数の中でどのように扱われようとも、元の状態のままになります。

### 参照渡し

参照渡し(pass by reference)とは、変数の実物をそのまま伝える方法です。

こちらの方法の場合は、関数の中で伝えた変数に変更を加えることで、元の状態ではなくなります。

### pythonの場合

~~~python
def double(x):
    x = x * 2
    return x
    
a = 1
print(a) # => 1
print(double(a)) # => 2
print(a) # => 1
~~~

~~~python
def double_first(x):
    x = x[0] * 2
    return x
    
a = [1, 2, 3]
print(a) # => [1, 2, 3]
print(double_first(a)) # => [2, 2, 3]
print(a) # => [2, 2, 3]
~~~

何かおかしいと思いませんか？

上の例ではもとのa = 1 は、doubleを呼んだ後でも元の状態を維持しています。

一方下の例は、a[0]の値はdouble_firstを呼ぶ前後で状態が違っています。

この理由はなかなか難しいですが、変数の挙動を正しく理解するには必要です。

### 参照の値渡し

変数はリテラルに名前をつけるもの、と説明しましたが、これは正確ではありません。

変数というのは、メモリ上にある場所を示す情報を持っているものになります。

例えば、1 という数値をプログラムに書いた場合、この 1 がメモリ上のどこかに配置されます。

そのメモリ上の場所を示すものを変数に記録することができる、という仕組みです。

メモリ上の場所を示すものを、「アドレス」と呼んだりします。

アドレスを調べるには、```id()``` という関数に変数を指定することで実現できます。

~~~python
a = 1 # => a には 1 という数値のメモリ上の場所を記録
print(id(a)) # => 例えば 12345678
print(id(1)) # => 上と同じIDを表示
a = 2 # => a には 2 という数値のメモリ上の場所を記録(1の場所は上書きされてなくなる)
print(id(a)) # => 例えば 4567890
print(id(1)) # => 前回と同じ(print(id(a))とは違う)IDを表示
~~~

構造を持つ変数の場合はもう少し複雑です。

例えばリストの場合、リスト自体の場所とともに、リストの各要素もすべて変数と同じ扱いとなり、
それぞれの要素のメモリ上の場所を記録している、ということになります。

~~~python
a = [1, 2, 3, 4] # => a には順番に 1, 2, 3, 4 という数値のメモリ上の場所をそれぞれ記録する
print(id(a)) # => a のメモリ上の場所
print(id([1, 2, 3, 4])) # => 新しいリストを作成するもので、a とは違う場所
print(id(a[0])) # => a[0] は 1
print(id(1)) # => a[0] と同じ場所
a[0] = a[0] * 2 # => a の最初の要素を書き換える(場所の情報を上書きする)
print(id(a)) # => a の場所は変わらない
print(id(a[0])) # => 2 に書き換えた a[0] の場所は変わっている
print(id(a[1])) # => a[1] は最初から 2 で、書き換えた a[0] と同じ場所
~~~
